# Nemo Backtesting Engine - Architecture

## 1. Overview

Nemo is a high-performance, event-driven backtesting engine designed for quantitative trading strategy development and evaluation. It is primarily built in C++ for speed and efficiency, with Python bindings for ease of use and rapid strategy prototyping. The engine simulates market behavior, processes trading signals generated by user-defined strategies, executes orders, and provides detailed performance analytics.

The architecture emphasizes modularity, allowing components like data handling, execution logic, risk management, and strategy implementation to be independently developed and extended.

## 2. Core Principles

*   **Event-Driven**: The system operates on a stream of events (market data, signals, orders, fills), managed by a central event bus. This allows for asynchronous processing and realistic simulation of market dynamics.
*   **Performance**: Critical components are implemented in C++ to ensure high throughput and low latency, crucial for processing large datasets and complex strategies.
*   **Modularity**: Components are loosely coupled, interacting primarily through the event bus and well-defined interfaces. This facilitates extensibility and testability.
*   **Extensibility**: Users can easily add new trading strategies in either C++ or Python, customize cost models, risk parameters, and data sources.
*   **Realism**: The engine incorporates features like simulated latency, order book dynamics, slippage, and commission costs to provide a more accurate backtesting environment.
*   **Python Integration**: Python bindings allow for strategy development in a popular and accessible language, leveraging C++ performance for the core engine.

## 3. System Diagram

```
+---------------------+      +---------------------+      +-----------------------+
|    Market Data      |<-----|   TickDataStore     |<-----|      Data Loader      |
| (CSV, DB, Live Feed)|      | (In-memory Storage) |      | (Parses & Feeds Data) |
+---------------------+      +---------------------+      +-----------------------+
          |                            ^
          | (MarketEvent)              | (MarketDataTick)
          v                            |
+---------------------+      +---------------------+      +-----------------------+
|     Event Bus       |----->|   BacktestEngine    |<---->|       SimClock        |
| (Central Dispatch)  |      | (Orchestration)     |      | (Time Management)     |
+---------------------+      +---------------------+      +-----------------------+
    ^          |                 |           ^                      |
    |          | (SignalEvent)   |           | (OrderEvent)         | (TimerEvent)
    |          v                 v           |                      v
+---------------------+  (Order) +---------------------+  (Fill) +-----------------------+
|  Strategy (C++/Py)  |--------->|  ExecutionHandler   |-------->|      OrderBook        |
| (Generates Signals) |          | (Order Management)  |         | (Matching Logic)      |
+---------------------+          +---------------------+         +-----------------------+
    |          ^                        |           ^
    |          | (FillEvent)            |           | (RiskEvent)
    |          |                        v           |
    |          +------------------------+-----------+
    |                                   |
    | (Risk Check)                      v
    +------------------------------+---------------------+
                                   |    RiskManager      |
                                   | (Pre/Post-Trade)    |
                                   +---------------------+
                                             |
                                             v
                                   +---------------------+
                                   |     CostModel       |
                                   | (Slippage, Comm.)   |
                                   +---------------------+
                                             |
                                             v
                                   +---------------------+
                                   |       Logger        |
                                   | (Events, Trades)    |
                                   +---------------------+
                                             |
                                             v
                                   +---------------------+
                                   |  Results & Metrics  |
                                   | (P&L, Drawdown etc.)|
                                   +---------------------+
```

## 4. Core Components

### 4.1. BacktestEngine (`core/engine.h`, `src/core/engine.cpp`)

*   **Responsibility**: Orchestrates the entire backtesting process. Initializes and manages all other core components. Controls the simulation loop, event dispatch, and result aggregation.
*   **Key Functions**:
    *   Loading market data via `TickDataStore`.
    *   Registering and initializing trading strategies.
    *   Managing the main event loop, driven by `SimClock` and `TickDataStore`.
    *   Coordinating interactions between strategies, `ExecutionHandler`, `RiskManager`, and `OrderBook`.
    *   Collecting and exporting backtest results and performance metrics.

### 4.2. Event Bus (`core/event_bus.h`)

*   **Responsibility**: Facilitates communication between components by dispatching events. Supports asynchronous and synchronous event publishing.
*   **Key Features**:
    *   Subscription model for specific event types or all events.
    *   Decouples event producers from consumers.
    *   Manages an event queue and a worker thread for asynchronous processing.
*   **Core Events (`core/events.h`)**:
    *   `MarketEvent`: New market data tick.
    *   `SignalEvent`: Trading signal generated by a strategy.
    *   `OrderEvent`: Order creation or modification request.
    *   `FillEvent`: Order execution confirmation.
    *   `RiskEvent`: Risk limit violation or other risk-related notifications.
    *   `TimerEvent`: Scheduled events for strategies or other components.

### 4.3. Simulation Clock (`core/sim_clock.h`)

*   **Responsibility**: Manages the concept of time within the simulation. Allows for advancing time based on market data or scheduled events.
*   **Key Features**:
    *   Provides current simulation time (`now()`).
    *   Allows advancing time to a specific point (`advance_to()`) or by a duration (`advance_by()`).
    *   Supports scheduling callbacks at future simulation times.
    *   A `MasterClock` can synchronize multiple `SimClock` instances if needed (though typically one main clock is used).

### 4.4. Tick Data Store (`data/tick_data_store.h`)

*   **Responsibility**: Stores and provides access to historical market data in an efficient, columnar format.
*   **Key Features**:
    *   Stores tick data (timestamps, bid/ask prices, sizes, last price, volume, OHLC) per instrument.
    *   Optimized for fast retrieval of tick ranges or individual ticks.
    *   Supports adding data incrementally and sorting by timestamp.
    *   Provides statistics about the stored data (total ticks, time range, memory usage).

### 4.5. Data Loader (`data_loader.h`, `src/data_loader.cpp`, `src/core/engine.cpp` for CSV loading)

*   **Responsibility**: Loads market data from various sources (currently CSV files) and populates the `TickDataStore`.
*   **Process**:
    1.  Reads data from a specified file (e.g., `data/stock_data.csv`).
    2.  Parses each row into a `MarketDataTick` struct.
    3.  Adds the `MarketDataTick` objects to the `TickDataStore` associated with the correct instrument.
*   **Extensibility**: Can be extended to support other data formats (e.g., binary files, databases) or live data feeds.

### 4.6. Strategy (`include/strategy/`, `src/strategy/`)

*   **Base Class**: `StrategyBase` (`include/strategy/strategy_base.h`, `src/strategy/strategy_base.cpp`)
    *   **Responsibility**: Abstract base class for all trading strategies. Defines the interface for receiving market data and other events.
    *   **Key Methods**:
        *   `initialize()`: Called once when the strategy is set up.
        *   `on_market_data(const MarketEvent& event)`: Called for each new market data tick relevant to the strategy.
        *   `on_fill(const FillEvent& event)`: Called when an order generated by the strategy is filled.
        *   `on_risk_event(const RiskEvent& event)`: Called for risk-related notifications.
        *   `on_timer(const TimerEvent& event)`: Called when a scheduled timer fires.
    *   **Helper Functions**: Provides methods to emit signals (`emit_buy_signal`, `emit_sell_signal`, `emit_close_signal`) which publish `SignalEvent`s to the `EventBus`.
*   **Example C++ Strategy**: `SimpleSMABroadStrategy` (`include/strategy/simple_sma_broad.h`, `src/strategy/simple_sma_broad.cpp`)
    *   Implements a strategy based on Simple Moving Averages and other indicators like RSI, ADX.
*   **Python Strategies**: (`strategies/python/`, `include/python/bindings.h`, `src/python/bindings.cpp`)
    *   The engine supports strategies written in Python.
    *   `PythonStrategy` C++ class acts as a wrapper around a Python strategy module.
    *   Python code can interact with the C++ engine through exposed API functions (e.g., `bt.signal_buy()`, `bt.get_strategy_pnl()`).
    *   See `strategies/python/sma_strategy.py` for an example.

### 4.7. Execution Handler (`include/core/engine.h` (nested class), `src/core/engine.cpp` (nested class impl.))

*   **Responsibility**: Manages the lifecycle of orders. Receives `SignalEvent`s (or direct order requests), validates them against risk limits, and converts them into `OrderEvent`s. Simulates order execution against the `OrderBook`.
*   **Process**:
    1.  Receives `SignalEvent` from a strategy (via `EventBus`).
    2.  Optionally, performs pre-trade risk checks using `RiskManager`.
    3.  Creates an `Order` object.
    4.  Publishes an `OrderEvent` to the `EventBus`.
    5.  Interacts with the `OrderBook` to match orders.
    6.  Applies costs (commission, slippage) using `CostModel`.
    7.  Publishes `FillEvent`s upon successful execution.
*   **Latency**: Incorporates configured order latency to simulate delays in order processing.

### 4.8. Order Router (`include/core/engine.h` (nested class), `src/core/engine.cpp` (nested class impl.))

*   **Responsibility**: Simulates the routing of orders to an exchange or matching engine. Primarily responsible for adding latency to order events before they reach the `OrderBook` or `ExecutionHandler`.
*   **Function**: Receives an `Order` and schedules its processing by the `ExecutionHandler` after a simulated delay, using the `SimClock`.

### 4.9. Order Book (`include/execution/order_book.h`)

*   **Responsibility**: Simulates a limit order book for a specific instrument. Matches incoming orders against existing resting orders.
*   **Key Features**:
    *   Maintains separate lists for bids (buy orders) and asks (sell orders), typically sorted by price and then time.
    *   Supports adding new limit orders.
    *   Executes market orders by consuming liquidity from the book.
    *   Attempts to match incoming limit orders; if not immediately fillable, the order rests on the book.
    *   Provides book depth information (L2 data).
*   **Matching Algorithms**: Can be configured with different matching algorithms (e.g., Price-Time priority).

### 4.10. Risk Manager (`include/strategy/risk_manager.h`)

*   **Responsibility**: Enforces risk limits at various stages (pre-trade, post-trade).
*   **Key Features**:
    *   Configurable risk limits (position size, notional exposure, loss limits, order rate limits, cooldown periods).
    *   Can apply global limits and strategy-specific limits.
    *   `check_order()`: Performs pre-trade validation. If a violation occurs, an order can be rejected, and a `RiskEvent` may be published.
    *   Updates internal state based on fills (`on_fill()`) to track positions, P&L, and exposure.
    *   Can trigger cooldown periods for strategies after significant losses.

### 4.11. Cost Model (`include/execution/cost_model.h`)

*   **Responsibility**: Calculates transaction costs, including commission and slippage.
*   **Key Features**:
    *   **Commission**: Supports various commission structures (per-trade fixed fee, percentage-based, maker/taker fees). Can be configured per exchange or per instrument.
    *   **Slippage**: Implements slippage models (e.g., `LinearSlippageModel`, `SqrtSlippageModel`) to simulate the price impact of trades. Slippage can depend on trade size and average daily volume.
    *   `calculate_cost()`: Returns the estimated commission and slippage for a potential trade.
    *   `calculate_fill_cost()`: Calculates costs for an actual `Fill`.

### 4.12. Logger (`include/utils/logging.h`, `src/logger/logger.cpp`)

*   **Responsibility**: Provides a flexible and structured logging facility for all components.
*   **Key Features**:
    *   Singleton access (`Logger::get()`).
    *   Configurable log levels (INFO, DEBUG, ERROR, etc.).
    *   Timestamped log entries.
    *   Outputs logs to a file (e.g., `logs/simpleSMABroad_trades.log`).
    *   Used extensively by `main.cpp`, `Backtester` (implicitly through `BacktestEngine`), and other components to record events, errors, and trade details.

### 4.13. Python Bindings (`include/python/bindings.h`, `src/python/bindings.cpp`)

*   **Responsibility**: Exposes C++ engine functionality to Python using Pybind11.
*   **Key Features**:
    *   Allows Python strategies to be loaded and run by the C++ engine.
    *   Provides Python API functions for:
        *   Engine control (initialize, load data, run backtest).
        *   Data access (get prices, timestamps).
        *   Position and P&L tracking.
        *   Order submission and signal emission from Python.
        *   Results export.
        *   Configuration and logging.
    *   The `PythonStrategy` C++ class acts as a bridge, forwarding calls from the engine to the corresponding methods in the Python strategy object.

## 5. Data Flow & Event Handling

1.  **Initialization**:
    *   `main.cpp` (or Python script via bindings) instantiates `BacktestEngine`.
    *   Engine initializes core components: `EventBus`, `SimClock`, `TickDataStore`, `RiskManager`, `CostModel`, `ExecutionHandler`, `OrderRouter`.
    *   Strategies (C++ or Python) are added to the engine.
    *   Market data is loaded into `TickDataStore` via `DataLoader` functionality. Data is sorted by timestamp.

2.  **Simulation Loop (Simplified)**:
    *   `BacktestEngine` starts the main loop.
    *   The loop iterates through time, driven by the timestamps of market data in `TickDataStore` or by `SimClock` for scheduled events.
    *   For each time step / market data tick:
        *   `SimClock` is advanced to the current event's timestamp.
        *   A `MarketEvent` is created for the current tick.
        *   `BacktestEngine` publishes the `MarketEvent` to the `EventBus`.
        *   Subscribed strategies receive the `MarketEvent` via their `on_market_data()` method.

3.  **Strategy Logic & Signal Generation**:
    *   Inside `on_market_data()`, a strategy analyzes the market data and its internal state.
    *   If trading conditions are met, the strategy emits a signal (e.g., BUY, SELL) by calling helper methods like `emit_buy_signal()`.
    *   These helpers create a `SignalEvent` and publish it to the `EventBus`.

4.  **Order Processing**:
    *   `ExecutionHandler` subscribes to `SignalEvent`s.
    *   Upon receiving a `SignalEvent`:
        *   It may perform pre-trade risk checks via `RiskManager`.
        *   If approved, it creates an `Order` object.
        *   It publishes an `OrderEvent` to the `EventBus`.
    *   The `OrderRouter` might intercept the `OrderEvent` to simulate latency, then re-publishes it (or forwards it directly to `ExecutionHandler` after a delay).
    *   `ExecutionHandler` (or a dedicated matching engine component interacting with `OrderBook`) processes the `OrderEvent`.
        *   For market orders, it attempts to match against the `OrderBook` for the instrument.
        *   For limit orders, it either matches immediately if possible or adds the order to the `OrderBook`.
    *   If a trade occurs (match found):
        *   `CostModel` is used to calculate commission and slippage.
        *   A `Fill` object is created.
        *   A `FillEvent` is published to the `EventBus`.

5.  **Post-Fill Processing**:
    *   Subscribed strategies receive the `FillEvent` via `on_fill()`, updating their internal position and P&L tracking.
    *   `RiskManager` receives the `FillEvent` to update its own position, exposure, and P&L records, and to check for post-trade risk violations (e.g., loss limits).
    *   `BacktestEngine` updates overall backtest results and metrics.

6.  **Logging & Results**:
    *   Throughout the process, components use the `Logger` to record significant events, trades, errors, and debug information.
    *   At the end of the backtest, `BacktestEngine` aggregates all data and can export:
        *   Trade logs (CSV).
        *   Performance summary (JSON, Markdown report).
        *   Detailed P&L curves, drawdown analysis, etc.

## 6. Strategy Upload and Management

*   **C++ Strategies**:
    *   Must inherit from `StrategyBase`.
    *   Implement required virtual methods (`on_market_data`, etc.).
    *   Compiled into the main engine executable or a dynamically linked library.
    *   Instantiated and added to the `BacktestEngine` in `main.cpp` or through configuration.
*   **Python Strategies**:
    *   Defined in Python modules (e.g., `strategies/python/sma_strategy.py`).
    *   Typically, a Python class with methods like `initialize`, `on_market_data`, `on_fill`.
    *   The C++ `PythonStrategy` wrapper loads the Python module and an instance of the strategy class.
    *   The wrapper translates calls from the C++ engine (e.g., `on_market_data`) to the corresponding Python methods.
    *   Python strategies use the provided Python API (`bt.*` functions) to interact with the engine (e.g., emit signals, get P&L).
    *   Added to the engine via `BacktestEngine::add_strategy(std::make_unique<PythonStrategy>(...))` or through Python bindings (`bt.add_strategy(...)`).

## 7. Build System (CMake)

*   **File**: `CMakeLists.txt`
*   **Configuration**:
    *   Sets C++ standard (e.g., C++17).
    *   Specifies include directories (`include/`).
    *   Finds all `.cpp` source files in `src/` and its subdirectories.
    *   Builds the main executable (e.g., `nemo`).
    *   Handles Pybind11 integration for Python bindings if enabled.
    *   May include custom commands for copying data files or other build/install steps.

## 8. Configuration

*   Currently, parameters like data file paths, strategy parameters (e.g., SMA windows), and initial capital are often hardcoded in `main.cpp` or passed during strategy instantiation.
*   The `include/utils/config.h` provides a `Config` struct, which is currently minimal but can be expanded to support loading configurations from files (e.g., JSON, YAML) for more flexible parameter management.
*   Python bindings also offer `set_config_value` and `get_config_value` for runtime configuration.

## 9. Extending the Engine

*   **New Trading Strategies**:
    *   **C++**: Create a new class inheriting from `StrategyBase`. Implement its virtual methods. Add to `BacktestEngine`.
    *   **Python**: Create a new Python module with a strategy class. Use the `PythonStrategy` wrapper or Python bindings to integrate.
*   **Data Sources**: Modify `DataLoader` logic or create new loaders to support different data formats or live feeds.
*   **Execution Models**: Enhance `ExecutionHandler` or `OrderBook` for more complex order types or matching logic.
*   **Risk Rules**: Add new checks to `RiskManager`.
*   **Cost Models**: Implement new `SlippageModel` or `CommissionStructure` types.
*   **Performance Metrics**: Extend `BacktestEngine::BacktestResults` and related calculation methods.

This architecture provides a robust and flexible foundation for advanced backtesting and quantitative strategy research.
